{"mode":"Text","hardwareTarget":"brain","textContent":"#region VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Brain should be defined by default\nbrain=Brain()\n\n# Robot configuration code\n\n\n# wait for rotation sensor to fully initialize\nwait(30, MSEC)\n\n\n# Make random actually random\ndef initializeRandomSeed():\n    wait(100, MSEC)\n    random = brain.battery.voltage(MV) + brain.battery.current(CurrentUnits.AMP) * 100 + brain.timer.system_high_res()\n    urandom.seed(int(random))\n      \n# Set random seed \ninitializeRandomSeed()\n\n\ndef play_vexcode_sound(sound_name):\n    # Helper to make playing sounds from the V5 in VEXcode easier and\n    # keeps the code cleaner by making it clear what is happening.\n    print(\"VEXPlaySound:\" + sound_name)\n    wait(5, MSEC)\n\n# add a small delay to make sure we don't print in the middle of the REPL header\nwait(200, MSEC)\n# clear the console to make sure we don't have the REPL in the console\nprint(\"\\033[2J\")\n\n#endregion VEXcode Generated Robot Configuration\nfrom vex import *\nimport urandom\n\n# Inicializa el cerebro y el controlador\nbrain = Brain()\ncontroller = Controller()\n\n# Configuración de los motores del tren motriz (solo traseros)\nmotor_back_left = Motor(Ports.PORT19, GearSetting.RATIO_18_1, True)  # Izquierdo\nmotor_back_right = Motor(Ports.PORT20, GearSetting.RATIO_18_1, False)  # Derecho\nmotor_front_left =  Motor(Ports.PORT17, GearSetting.RATIO_18_1, False)\nmotor_front_right = Motor(Ports.PORT16, GearSetting.RATIO_18_1, True)\n\n# Configuración de los motores para la garra, cepillo, rampa y pinza\nmotor_rampa = Motor(Ports.PORT11, GearSetting.RATIO_6_1, True)\nmotor_cepillo = Motor(Ports.PORT10, GearSetting.RATIO_18_1, False)\nmotor_garra_open_close = Motor(Ports.PORT12, GearSetting.RATIO_36_1, False)\nmotor_pinza_open_close = Motor(Ports.PORT14, GearSetting.RATIO_36_1, False)\n\n# Variable para el control del cepillo\ncepillo_on = False\nprev_ButtonA = False\n\n# Variables para modos y detección de botones\nmodo_rampa_auto = False\nprev_ButtonB = False\n\n# Umbral de zona muerta\nDEADZONE = 5\n\n\n##############################################\n# Funciones de Movimiento (Tren motriz)\n##############################################\ndef mover_adelante(velocidad):\n    motor_back_left.spin(REVERSE, velocidad, PERCENT)\n    motor_back_right.spin(REVERSE, velocidad, PERCENT)\n    motor_front_left.spin(FORWARD, velocidad, PERCENT)\n    motor_front_right.spin(FORWARD, velocidad, PERCENT)\n\ndef mover_atras(velocidad):\n    motor_back_left.spin(FORWARD, velocidad, PERCENT)\n    motor_back_right.spin(FORWARD, velocidad, PERCENT)\n    motor_front_left.spin(REVERSE, velocidad, PERCENT)\n    motor_front_right.spin(REVERSE, velocidad, PERCENT)\n\ndef girar_izquierda(velocidad):\n    motor_front_left.spin(REVERSE,  velocidad, PERCENT)\n    motor_back_left.spin(REVERSE,   velocidad, PERCENT)\n    motor_front_right.spin(FORWARD, velocidad, PERCENT)\n    motor_back_right.spin(FORWARD,  velocidad, PERCENT)\n\ndef girar_derecha(velocidad):\n    motor_front_left.spin(FORWARD,   velocidad, PERCENT)\n    motor_back_left.spin(FORWARD,    velocidad, PERCENT)\n    motor_front_right.spin(REVERSE,  velocidad, PERCENT)\n    motor_back_right.spin(REVERSE,   velocidad, PERCENT)\n\n# Movimientos laterales (Strafe) con llantas mecanum\ndef girarc_izquierda(velocidad):\n    # Ajusta FORWARD/REVERSE si se mueve al lado contrario\n    motor_front_left.spin(REVERSE,  velocidad, PERCENT)\n    motor_back_left.spin(REVERSE,   velocidad, PERCENT)\n    motor_front_right.spin(FORWARD, velocidad, PERCENT)\n    motor_back_right.spin(FORWARD,  velocidad, PERCENT)\n\ndef girarc_derecha(velocidad):\n    # Ajusta FORWARD/REVERSE si se mueve al lado contrario\n    motor_front_left.spin(FORWARD,   velocidad, PERCENT)\n    motor_back_left.spin(FORWARD,    velocidad, PERCENT)\n    motor_front_right.spin(REVERSE,  velocidad, PERCENT)\n    motor_back_right.spin(REVERSE,   velocidad, PERCENT)\n\ndef detener():\n    motor_back_left.stop()\n    motor_back_right.stop()\n    motor_front_left.stop()\n    motor_front_right.stop()\n\n\ndef control_drive():\n    # Leer ejes del joystick\n    axis_forward = controller.axis3.position()  # Adelante / Atrás\n    axis_strafe  = controller.axis4.position()  # Izquierda / Derecha (strafe)\n\n    # Aplicar zona muerta\n    if abs(axis_forward) < DEADZONE:\n        axis_forward = 0\n    if abs(axis_strafe) < DEADZONE:\n        axis_strafe = 0\n\n    # Si hay valor en axis_strafe, nos movemos lateralmente\n    if axis_strafe > 0:\n        # Strafe a la derecha\n        # Equivalente a tu girarc_derecha(velocidad)\n        motor_front_left.spin(FORWARD,   axis_strafe, PERCENT)\n        motor_back_left.spin(REVERSE,    axis_strafe, PERCENT)\n        motor_front_right.spin(REVERSE,  axis_strafe, PERCENT)\n        motor_back_right.spin(FORWARD,   axis_strafe, PERCENT)\n \n    elif axis_strafe < 0:\n        # Strafe a la izquierda\n        # Equivalente a tu girarc_izquierda(velocidad)\n        speed = abs(axis_strafe)\n        motor_front_left.spin(REVERSE,  speed, PERCENT)\n        motor_back_left.spin(FORWARD,   speed, PERCENT)\n        motor_front_right.spin(FORWARD, speed, PERCENT)\n        motor_back_right.spin(REVERSE,  speed, PERCENT)\n\n    # Si no hay valor en axis_strafe, vemos si hay valor en axis_forward\n    elif axis_forward > 0:\n        mover_adelante(axis_forward)\n    elif axis_forward < 0:\n        mover_atras(abs(axis_forward))\n\n    # Si ninguno de los ejes está activo, detenemos\n    else:\n        detener()\n\n# Función para el control de la rampa con joystick derecho (Axis 2)\ndef control_rampa():\n    value = controller.axis2.value()\n    if abs(value) < DEADZONE:\n        motor_rampa.stop()\n    else:\n        direction = REVERSE if value > 0 else FORWARD\n        motor_rampa.spin(direction, abs(value), PERCENT)\n\n\n# Función para aplicar el control automático de la rampa (370 RPM)\ndef aplicar_rampa_auto():\n    motor_rampa.set_velocity(370, RPM)\n    motor_rampa.spin(FORWARD)\n\n# Función para alternar el modo de la rampa (manual/automático)\ndef toggle_rampa_mode():\n    global modo_rampa_auto, prev_ButtonB\n    if controller.buttonB.pressing() and not prev_ButtonB:\n        modo_rampa_auto = not modo_rampa_auto\n    prev_ButtonB = controller.buttonB.pressing()\n\n\n# Control gradual de la garra\ndef control_garra_gradual():\n    if controller.buttonL1.pressing():\n        motor_garra_open_close.spin(FORWARD, 60, PERCENT)\n    elif controller.buttonR1.pressing():\n        motor_garra_open_close.spin(REVERSE, 60, PERCENT)\n    else:\n        motor_garra_open_close.stop(HOLD)\n\n# Control gradual de la pinza\ndef control_pinza_gradual():\n    if controller.buttonL2.pressing():\n        motor_pinza_open_close.spin(FORWARD, 100, PERCENT)\n    elif controller.buttonR2.pressing():\n        motor_pinza_open_close.spin(REVERSE, 100, PERCENT)\n    else:\n        motor_pinza_open_close.stop(HOLD)\n\ndef girar_cepillo():\n    global cepillo_on, prev_ButtonA\n    \n    if controller.buttonA.pressing() and not prev_ButtonA:\n        cepillo_on = not cepillo_on\n        if cepillo_on:\n            motor_cepillo.spin(REVERSE, 100, PERCENT)\n        else:\n            motor_cepillo.stop()\n    \n    prev_ButtonA = controller.buttonA.pressing()\n\n\n# Bucle principal\ndef main():\n    while True:\n        control_drive()\n        control_rampa()\n        girar_cepillo()\n        control_pinza_gradual()\n        control_garra_gradual()\n\n# Alterna y aplica el modo de control de la rampa\n        toggle_rampa_mode()\n        if modo_rampa_auto:\n            aplicar_rampa_auto()\n        else:\n            control_rampa()\n\n        wait(20, MSEC)\n\nif __name__ == '__main__':\n    main()\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.9","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false}