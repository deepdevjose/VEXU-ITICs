{"mode":"Text","hardwareTarget":"brain","textContent":"# ================================================================\n# VEXcode – Configuración y Teleoperado (Robot con llantas mecanum)\n# ---------------------------------------------------------------\n# Descripción:\n#   Control de un robot con tren motriz de 4 motores (mecanum) y\n#   actuadores adicionales: rampa, cepillo, garra y pinza.\n#\n#   • Conducción tipo arcade:\n#       - Axis3: avance/retroceso\n#       - Axis4: strafe lateral (izquierda/derecha)\n#   • Strafe forzado (botones):\n#       - LEFT / RIGHT: strafe a velocidad fija (50%)\n#   • Rampa:\n#       - Axis2: modo manual (cuando el modo AUTO está apagado)\n#       - Botón B: alterna modo rampa AUTO (RPM fijo) / MANUAL\n#   • Cepillo:\n#       - Botón A: alterna encendido/apagado\n#   • Garra:\n#       - L1 abre (FORWARD), R1 cierra (REVERSE) con retención\n#   • Pinza:\n#       - L2 abre (FORWARD), R2 cierra (REVERSE) con retención\n#\n# Notas:\n#   - Usa zona muerta (DEADZONE) para ignorar ruido del joystick.\n#   - El valor de RPM para rampa en AUTO es 470 RPM.\n#   - Ajusta inversión (reversa) de motores según cableado real.\n#\n# Autor: @deepdevjose - github.com/deepdevjose\n# ================================================================\n\nfrom vex import *\n\n# ------------------------------------------------\n# Inicialización del cerebro y controlador\n# ------------------------------------------------\nbrain = Brain()\ncontroller = Controller()\n\n# ------------------------------------------------\n# Constantes de configuración\n# ------------------------------------------------\nDEADZONE = 10  # Umbral para ignorar pequeños valores del joystick (ruido)\n\n# ------------------------------------------------\n# Motores del tren motriz (mecanum)\n#   Ajusta el tercer parámetro (invertido) si tu robot se mueve al revés.\n# ------------------------------------------------\nmotor_back_left   = Motor(Ports.PORT12, GearSetting.RATIO_18_1, True)   # Izquierdo trasero\nmotor_back_right  = Motor(Ports.PORT2,  GearSetting.RATIO_18_1, False)  # Derecho trasero\nmotor_front_left  = Motor(Ports.PORT1,  GearSetting.RATIO_18_1, False)  # Izquierdo delantero\nmotor_front_right = Motor(Ports.PORT11, GearSetting.RATIO_18_1, True)   # Derecho delantero\n\n# ------------------------------------------------\n# Otros actuadores\n# ------------------------------------------------\nmotor_rampa            = Motor(Ports.PORT10, GearSetting.RATIO_6_1,  False)\nmotor_cepillo          = Motor(Ports.PORT20, GearSetting.RATIO_36_1, False)\nmotor_garra_open_close = Motor(Ports.PORT19, GearSetting.RATIO_36_1, False)\nmotor_pinza_open_close = Motor(Ports.PORT6,  GearSetting.RATIO_36_1, False)\n\n# ------------------------------------------------\n# Variables de estado global\n# ------------------------------------------------\nmodo_rampa_auto = False     # True = AUTO (RPM fija); False = manual con Axis2\nprev_ButtonB    = False     # Flanco para toggle de rampa\ncepillo_on      = False     # Estado ON/OFF del cepillo\nprev_ButtonA    = False     # Flanco para toggle del cepillo\n\n# ================================================================\n# Funciones de movimiento (Tren motriz)\n# ================================================================\ndef mover_adelante(velocidad: int) -> None:\n    \"\"\"Mueve el robot hacia adelante a 'velocidad' (%).\"\"\"\n    motor_back_left.spin(FORWARD,  velocidad, PERCENT)\n    motor_back_right.spin(FORWARD, velocidad, PERCENT)\n    motor_front_left.spin(FORWARD, velocidad, PERCENT)\n    motor_front_right.spin(FORWARD, velocidad, PERCENT)\n\ndef mover_atras(velocidad: int) -> None:\n    \"\"\"Mueve el robot hacia atrás a 'velocidad' (%).\"\"\"\n    motor_back_left.spin(REVERSE,  velocidad, PERCENT)\n    motor_back_right.spin(REVERSE, velocidad, PERCENT)\n    motor_front_left.spin(REVERSE, velocidad, PERCENT)\n    motor_front_right.spin(REVERSE, velocidad, PERCENT)\n\ndef girar_izquierda(velocidad: int) -> None:\n    \"\"\"Giro en su lugar hacia la izquierda (diferencial).\"\"\"\n    motor_front_left.spin(REVERSE,  velocidad, PERCENT)\n    motor_back_left.spin(FORWARD,   velocidad, PERCENT)\n    motor_front_right.spin(FORWARD, velocidad, PERCENT)\n    motor_back_right.spin(REVERSE,  velocidad, PERCENT)\n\ndef girar_derecha(velocidad: int) -> None:\n    \"\"\"Giro en su lugar hacia la derecha (diferencial).\"\"\"\n    motor_front_left.spin(FORWARD,   velocidad, PERCENT)\n    motor_back_left.spin(REVERSE,    velocidad, PERCENT)\n    motor_front_right.spin(REVERSE,  velocidad, PERCENT)\n    motor_back_right.spin(FORWARD,   velocidad, PERCENT)\n\ndef girarc_izquierda(velocidad: int) -> None:\n    \"\"\"Movimiento lateral (strafe) hacia la izquierda con llantas mecanum.\"\"\"\n    motor_front_left.spin(REVERSE,  velocidad, PERCENT)\n    motor_back_left.spin(REVERSE,   velocidad, PERCENT)\n    motor_front_right.spin(FORWARD, velocidad, PERCENT)\n    motor_back_right.spin(FORWARD,  velocidad, PERCENT)\n\ndef girarc_derecha(velocidad: int) -> None:\n    \"\"\"Movimiento lateral (strafe) hacia la derecha con llantas mecanum.\"\"\"\n    motor_front_left.spin(FORWARD,   velocidad, PERCENT)\n    motor_back_left.spin(FORWARD,    velocidad, PERCENT)\n    motor_front_right.spin(REVERSE,  velocidad, PERCENT)\n    motor_back_right.spin(REVERSE,   velocidad, PERCENT)\n\ndef detener() -> None:\n    \"\"\"Detiene los cuatro motores del tren motriz.\"\"\"\n    motor_back_left.stop()\n    motor_back_right.stop()\n    motor_front_left.stop()\n    motor_front_right.stop()\n\n# ================================================================\n# Funciones de control de actuadores (Rampa, Garra, Pinza, Cepillo)\n# ================================================================\ndef control_rampa_manual() -> None:\n    \"\"\"\n    Control MANUAL de la rampa con Axis2.\n    - Aplica DEADZONE para evitar movimientos involuntarios.\n    - Mantiene proporción de velocidad con el valor del joystick.\n    \"\"\"\n    value = controller.axis2.position()\n    if abs(value) < DEADZONE:\n        motor_rampa.stop()\n    else:\n        direction = FORWARD if value > 0 else REVERSE\n        motor_rampa.spin(direction, abs(value), PERCENT)\n\ndef aplicar_rampa_auto() -> None:\n    \"\"\"\n    Control AUTO de la rampa.\n    - Fija la velocidad a 470 RPM y gira en sentido FORWARD.\n    - Ajusta RPM según tu mecánica real si es necesario.\n    \"\"\"\n    motor_rampa.set_velocity(470, RPM)\n    motor_rampa.spin(FORWARD)\n\ndef toggle_rampa_mode() -> None:\n    \"\"\"\n    Alterna entre modo de rampa AUTO/MANUAL con flanco del botón B.\n    - Usa 'prev_ButtonB' para evitar rebotes (toggle por pulsación).\n    \"\"\"\n    global modo_rampa_auto, prev_ButtonB\n    if controller.buttonB.pressing() and not prev_ButtonB:\n        modo_rampa_auto = not modo_rampa_auto\n    prev_ButtonB = controller.buttonB.pressing()\n\ndef control_garra_gradual() -> None:\n    \"\"\"\n    Control de la garra con retención (HOLD):\n    - L1: abre (FORWARD) al 60%\n    - R1: cierra (REVERSE) al 60%\n    - Sin pulsación: mantiene posición (HOLD)\n    \"\"\"\n    if controller.buttonL1.pressing():\n        motor_garra_open_close.spin(FORWARD, 60, PERCENT)\n    elif controller.buttonR1.pressing():\n        motor_garra_open_close.spin(REVERSE, 60, PERCENT)\n    else:\n        motor_garra_open_close.stop(HOLD)\n\ndef control_pinza_gradual() -> None:\n    \"\"\"\n    Control de la pinza con retención (HOLD):\n    - L2: abre (FORWARD) al 100%\n    - R2: cierra (REVERSE) al 100%\n    - Sin pulsación: mantiene posición (HOLD)\n    \"\"\"\n    if controller.buttonL2.pressing():\n        motor_pinza_open_close.spin(FORWARD, 100, PERCENT)\n    elif controller.buttonR2.pressing():\n        motor_pinza_open_close.spin(REVERSE, 100, PERCENT)\n    else:\n        motor_pinza_open_close.stop(HOLD)\n\ndef girar_cepillo() -> None:\n    \"\"\"\n    Toggle ON/OFF del cepillo con botón A usando flanco:\n    - ON: gira en REVERSE al 100%\n    - OFF: se detiene\n    \"\"\"\n    global cepillo_on, prev_ButtonA\n    if controller.buttonA.pressing() and not prev_ButtonA:\n        cepillo_on = not cepillo_on\n        if cepillo_on:\n            motor_cepillo.spin(REVERSE, 100, PERCENT)\n        else:\n            motor_cepillo.stop()\n    prev_ButtonA = controller.buttonA.pressing()\n\n# ================================================================\n# Conducción – Arcade (Axis3 avance/retro, Axis4 strafe)\n# ================================================================\ndef control_drive() -> None:\n    \"\"\"\n    Control principal de conducción tipo arcade:\n      - Axis3: avance (+) / retroceso (–)\n      - Axis4: strafe derecha (+) / izquierda (–)\n    Prioridad:\n      1) Si hay strafe (Axis4 ≠ 0), se mueve lateralmente.\n      2) Si no hay strafe pero hay avance (Axis3 ≠ 0), avanza/retrocede.\n      3) Si no hay entradas activas, detiene el tren motriz.\n    \"\"\"\n    # Lectura de ejes\n    axis_forward = controller.axis3.position()  # Adelante / Atrás\n    axis_strafe  = controller.axis4.position()  # Izquierda / Derecha (strafe)\n\n    # Zona muerta\n    if abs(axis_forward) < DEADZONE:\n        axis_forward = 0\n    if abs(axis_strafe) < DEADZONE:\n        axis_strafe = 0\n\n    # 1) Strafe tiene prioridad\n    if axis_strafe > 0:\n        # Strafe a la derecha\n        motor_front_left.spin(FORWARD,   axis_strafe, PERCENT)\n        motor_back_left.spin(REVERSE,    axis_strafe, PERCENT)\n        motor_front_right.spin(REVERSE,  axis_strafe, PERCENT)\n        motor_back_right.spin(FORWARD,   axis_strafe, PERCENT)\n\n    elif axis_strafe < 0:\n        # Strafe a la izquierda\n        speed = abs(axis_strafe)\n        motor_front_left.spin(REVERSE,  speed, PERCENT)\n        motor_back_left.spin(FORWARD,   speed, PERCENT)\n        motor_front_right.spin(FORWARD, speed, PERCENT)\n        motor_back_right.spin(REVERSE,  speed, PERCENT)\n\n    # 2) Avance/retro si no hay strafe\n    elif axis_forward > 0:\n        mover_adelante(axis_forward)\n    elif axis_forward < 0:\n        mover_atras(abs(axis_forward))\n    # 3) Sin entradas -> detener\n    else:\n        detener()\n\n# ================================================================\n# Bucle principal (Teleoperado)\n# ================================================================\ndef main() -> None:\n    \"\"\"\n    Bucle teleoperado:\n      - Alterna/aplica modo rampa AUTO/MANUAL.\n      - Actualiza cepillo, pinza y garra.\n      - Actualiza movimiento base (arcade).\n      - Botones LEFT/RIGHT fuerzan strafe a 50% (útil para ajustes finos).\n      - Espera 20 ms para no saturar CPU.\n    \"\"\"\n    while True:\n        # Rampa\n        toggle_rampa_mode()\n        if modo_rampa_auto:\n            aplicar_rampa_auto()\n        else:\n            control_rampa_manual()\n\n        # Actuadores\n        girar_cepillo()\n        control_pinza_gradual()\n        control_garra_gradual()\n\n        # Movimiento base\n        control_drive()\n\n        # Strafe forzado\n        if controller.buttonLeft.pressing():\n            girarc_izquierda(50)\n        elif controller.buttonRight.pressing():\n            girarc_derecha(50)\n\n        # Pequeña pausa para estabilidad\n        wait(20, MSEC)\n\n# ------------------------------------------------\n# Punto de entrada\n# ------------------------------------------------\nif __name__ == \"__main__\":\n    main()\n","textLanguage":"python","robotConfig":[],"slot":0,"platform":"V5","sdkVersion":"20240802.15.00.00","appVersion":"4.0.12","fileFormat":"2.0.0","targetBrainGen":"First","v5Sounds":[{"name":"game over","url":"static/sounds/mixkit-arcade-retro-game-over-213.wav"}],"v5SoundsEnabled":false}